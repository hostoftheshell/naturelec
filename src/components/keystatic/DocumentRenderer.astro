---
/**
 * Renders Keystatic document field content
 * Supports: paragraphs, headings, lists, links, inline formatting (bold, italic, code, strikethrough)
 */

interface Props {
	content: any; // Keystatic document type (array of nodes)
	class?: string;
}

const { content, class: className = "" } = Astro.props;

// Apply lightweight inline Markdown for cases where content comes as raw text
// Supports: code `code`, bold **text** or __text__, italic *text* or _text_, strikethrough ~~text~~
function applyInlineMarkdown(text: string): string {
	if (!text) return "";

	// Escape HTML special chars to avoid injection before adding our own tags
	const escaped = text
		.replace(/&/g, "&amp;")
		.replace(/</g, "&lt;")
		.replace(/>/g, "&gt;")
		.replace(/"/g, "&quot;")
		.replace(/'/g, "&#39;");

	// Code spans first to avoid interfering with other markers inside code
	let out = escaped.replace(
		/`([^`]+)`/g,
		'<code class="bg-muted px-1 py-0.5 rounded text-sm font-mono">$1</code>',
	);

	// Links: [text](url) — do this before bold/italic
	out = out.replace(
		/\[([^\]]+)\]\(([^)]+)\)/g,
		'<a href="$2" class="text-link hover:text-link-hover hover:underline font-medium transition-colors">$1</a>',
	);

	// Bold (greedy but contained) – handle **text** and __text__
	out = out.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
	out = out.replace(/__([^_]+)__/g, "<strong>$1</strong>");

	// Italic – handle *text* and _text_ (avoid matching bold already handled)
	out = out.replace(/(^|\W)\*([^*]+)\*(?=\W|$)/g, "$1<em>$2</em>");
	out = out.replace(/(^|\W)_([^_]+)_(?=\W|$)/g, "$1<em>$2</em>");

	// Strikethrough
	out = out.replace(/~~([^~]+)~~/g, "<s>$1</s>");

	return out;
}

// Helper to render inline content (text with marks like bold, italic, etc.)
function renderInline(node: any): string {
	if (typeof node === "string") return applyInlineMarkdown(node);
	if (!node) return "";

	// Handle inline link nodes (e.g., produced by .mdoc parsing)
	if (node.type === "link") {
		const linkText = node.children?.map(renderInline).join("") || "";
		const linkHref = node.href || "#";
		return `<a href="${linkHref}" class="text-link hover:text-link-hover hover:underline font-medium transition-colors">${linkText}</a>`;
	}

	let text = node.text || "";

	// Apply marks (bold, italic, code, etc.)
	if (node.bold) text = `<strong>${text}</strong>`;
	if (node.italic) text = `<em>${text}</em>`;
	if (node.code)
		text = `<code class="bg-muted px-1 py-0.5 rounded text-sm font-mono">${text}</code>`;
	if (node.strikethrough) text = `<s>${text}</s>`;

	// If no explicit marks are set (common when parsing raw .mdoc paragraphs),
	// apply a minimal inline markdown pass so *italic* / **bold** render correctly
	const hasExplicitMarks = !!(node.bold || node.italic || node.code || node.strikethrough);
	return hasExplicitMarks ? text : applyInlineMarkdown(text);
}

// Helper to render a block node
function renderBlock(node: any): string {
	if (!node || !node.type) return "";

	switch (node.type) {
		case "paragraph": {
			const paragraphContent = node.children?.map(renderInline).join("") || "";
			return paragraphContent ? `<p class="mb-3 last:mb-0">${paragraphContent}</p>` : "";
		}

		case "heading": {
			const level = node.level || 3;
			const headingContent = node.children?.map(renderInline).join("") || "";
			const headingClass =
				level === 3
					? "text-lg font-semibold mb-2 mt-4 first:mt-0"
					: level === 4
						? "text-base font-semibold mb-2 mt-3 first:mt-0"
						: "text-sm font-semibold mb-1 mt-2 first:mt-0";
			return `<h${level} class="${headingClass}">${headingContent}</h${level}>`;
		}

		case "list": {
			const listItems = node.children
				?.map((item: any) => {
					// Render list items using inline rendering to avoid extra paragraphs
					const itemContent = (item.children || []).map(renderInline).join("");
					return `<li class="mb-1">${itemContent}</li>`;
				})
				.join("");

			return node.listType === "ordered"
				? `<ol class="list-decimal list-inside mb-3 space-y-1">${listItems}</ol>`
				: `<ul class="list-disc list-inside mb-3 space-y-1">${listItems}</ul>`;
		}

		case "blockquote": {
			const quoteContent = node.children?.map(renderBlock).join("") || "";
			return `<blockquote class="border-l-4 border-accent pl-4 italic mb-3 text-muted-foreground">${quoteContent}</blockquote>`;
		}

		case "link": {
			const linkText = node.children?.map(renderInline).join("") || "";
			const linkHref = node.href || "#";
			return `<a href="${linkHref}" class="text-link hover:text-link-hover hover:underline font-medium transition-colors">${linkText}</a>`;
		}

		default:
			// For unknown types, try to render children
			if (node.children) {
				return node.children
					.map((child: any) => {
						// If child has a type, render as block
						if (child.type) return renderBlock(child);
						// Otherwise render as inline
						return renderInline(child);
					})
					.join("");
			}
			return "";
	}
}

// Render the entire document
const html = Array.isArray(content) ? content.map(renderBlock).join("") : "";
---

{html && <div class:list={["keystatic-document", className]} set:html={html} />}
